### 1\. Errores Críticos e Inconsistencias (Blockers)

Estos son problemas que romperán la aplicación o los tests en un entorno real.

**A. Inconsistencia entre Tests y Migraciones (Tabla Fantasma)**

  * **Problema:** La migración `20251208063546_add_kardex_movimientos_inventario` **elimina** la tabla `InventarioAjustes` (`DROP TABLE InventarioAjustes`). Sin embargo, el archivo de test `tests/integration/kardex-fiscal.test.ts` (líneas 160, 245) intenta escribir directamente en `db.inventarioAjustes`.
  * **Consecuencia:** Los tests de integración fallarán sistemáticamente porque la tabla ya no existe en el esquema actual de Prisma ni en la BD.
  * **Solución:** Actualizar los tests para usar el servicio de inventario (`inventario.service.ts`) o escribir en `MovimientosInventario` con `referencia_tipo: 'AJUSTE'`.

**B. Race Condition Parcial en Ventas**

  * **Archivo:** `src/models/venta.model.ts` (función `createVenta`).
  * **Problema:** Se realiza una validación de stock *antes* de la transacción atómica:
    ```typescript
    if (Number(producto.stock) < Number(detalle.cantidad)) { ... }
    ```
    Aunque `inventario.service.ts` implementa bloqueo optimista (lo cual es excelente), la validación previa en el modelo de venta es redundante y puede dar falsos positivos en alta concurrencia (lectura sucia antes de que el servicio intente la escritura).
  * **Recomendación:** Confiar puramente en el `inventarioService.registrarMovimiento` para la validación de stock o realizar un `SELECT ... FOR UPDATE` si se quiere validar antes.

**C. Problemas de Precisión Numérica (JS Numbers)**

  * **Contexto:** El proyecto utiliza `Decimal` en la base de datos (Prisma), pero en el código TypeScript (ej. `src/services/igv-calculator.service.ts`, `src/models/venta.model.ts`) se convierte constantemente a `Number` de JavaScript (`Number(val)`).
  * **Riesgo:** JavaScript utiliza coma flotante binaria (IEEE 754). Operaciones como `0.1 + 0.2` no dan `0.3`. Aunque se usa `.toFixed(2)`, realizar cálculos aritméticos complejos (multiplicación de precios por cantidad e impuestos) usando `Number` generará errores de centavos en facturación masiva.
  * **Solución:** Utilizar una librería como `decimal.js` para manejar la aritmética en el backend, manteniendo los tipos `Decimal` de Prisma el mayor tiempo posible sin pasarlos a `Number` hasta el momento de la respuesta JSON.

### 2\. Análisis del Schema de Base de Datos (`prisma/schema.prisma`)

**A. Puntos Fuertes**

  * **Multi-tenancy:** Correcta implementación de `tenant_id` en todas las tablas transaccionales y maestras.
  * **Relaciones:** Buen uso de `onDelete: Cascade` para integridad referencial en cascada (ej. borrar un Tenant borra sus datos).
  * **Indices:** Buen indexado en claves foráneas y campos de búsqueda comunes.

**B. Debilidades y Riesgos**

  * **Almacenamiento JSON como String:** En la tabla `Tenants`, el campo `configuracion` se define como `String? @db.LongText`.
      * *Mala Práctica:* MySQL soporta tipos nativos `JSON`. Usar `LongText` impide realizar consultas eficientes sobre atributos dentro del JSON (ej. "buscar todos los tenants con facturación electrónica habilitada").
      * *Mejora:* Cambiar a tipo `Json` de Prisma/MySQL.
  * **Tipos Decimales Inconsistentes:**
      * En `MovimientosInventario`, `cantidad` es `Decimal(12, 3)`.
      * En `VentaDetalles`, `cantidad` es `Decimal(12, 3)`.
      * *Sin embargo*, en `Productos`, `precio_base` ha cambiado a `Decimal(12, 4)` (migración `fiscal_integrity_blindaje`), pero otros montos monetarios en `Ventas` (`total`, `monto_pagado`) siguen en `Decimal(12, 2)`.
      * *Riesgo:* Al sumar detalles con 4 decimales, el total en cabecera con 2 decimales puede tener descuadres de redondeo si no se gestiona explícitamente el redondeo ("Banker's rounding" vs "Round half up").
  * **Modelo de Auditoría Pesado:** La tabla `AuditoriaLogs` almacena `datos_antes` y `datos_despues` como `LongText`. En un sistema de alta transaccionalidad, esta tabla crecerá exponencialmente, degradando el rendimiento de la base de datos y los backups. Se recomienda mover auditoría a una base de datos NoSQL (Mongo/Elastic) o una tabla particionada.

### 3\. Análisis de Código y Arquitectura

**A. Seguridad**

  * **Falta de Rate Limiting:** No veo middleware de `express-rate-limit`. Esto expone el API a ataques de fuerza bruta (especialmente en `/api/auth/login`) y DDoS.
  * **Subdominios y CORS:** El manejo de CORS en `src/index.ts` permite `*.localhost:5173`. Es aceptable para desarrollo, pero en producción se debe validar estrictamente contra los dominios permitidos del tenant para evitar ataques de origen cruzado si un subdominio es comprometido.
  * **Exposición de Stack Trace:** En `src/index.ts`, el error handler global expone `err.stack` si no es producción. Asegurarse estrictamente de que `NODE_ENV` sea `production` en el despliegue.

**B. Estructura y Mantenibilidad**

  * **Archivos Muertos:** Existe `src/routes/ventas.routes.ts.backup`. Esto es una mala práctica ("código comentado"). Se debe confiar en Git para el historial, no dejar archivos basura en el repositorio.
  * **Dependencia Circular en Lógica de Negocio:**
      * `src/models/sesion-caja.model.ts` importa y consulta `db.ventas`.
      * `src/models/venta.model.ts` importa y consulta `db.sesionesCaja`.
      * Esto crea un acoplamiento fuerte. Si cambias la lógica de cajas, rompes ventas y viceversa. Sería mejor usar un patrón de eventos o un servicio orquestador superior.

**C. Calidad del Código TypeScript**

  * **Uso excesivo de `any` en manejo de errores:**
    ```typescript
    } catch (error: any) {
      if (error?.code === '...')
    ```
    Aunque es común, se pierde el tipado. Sería mejor crear una clase `AppError` o usar tipos discriminados para errores conocidos de Prisma.
  * **Validación de `tenant_id`:** El middleware `checkTenant` inyecta el `tenantId`. Sin embargo, en varios controllers se hace `req.tenantId!`. Si el middleware fallara o se omitiera en la ruta por error humano, esto lanzaría una excepción no controlada.

### 4\. Detalles Específicos por Archivo

1.  **`src/services/storage.service.ts`**:

      * La función `uploadToCloudinary` usa `resource_type: 'image'`. Si intentan subir un PDF (ej. un manual de producto), fallará o lo tratará incorrectamente. Se debería validar el mime-type antes de llamar a esta función o parametrizar el tipo.
      * *Bug potencial:* `deleteFromCloudinary` asume una estructura de URL específica de Cloudinary. Si Cloudinary cambia su estructura de URL o si se usa un dominio personalizado (CNAME), la extracción del `public_id` fallará silenciosamente (devuelve `false`).

2.  **`src/services/facturador.service.ts`**:

      * La implementación `NubefactService` realiza `console.log` con datos de facturación. **Riesgo de seguridad/privacidad**: No se deben loguear datos sensibles de clientes o montos en logs de producción a menos que estén ofuscados.

3.  **`src/controllers/public.controller.ts`**:

      * `createCheckoutPublicoHandler`: Crea un cliente nuevo si no existe.
      * *Riesgo:* Un atacante puede enumerar correos electrónicos o saturar la base de datos de clientes enviando peticiones con emails aleatorios o ajenos. Debería requerir algún tipo de captcha o validación de email antes de crear el registro persistente.

4.  **`src/config/catalogo-sunat.ts`**:

      * Está hardcodeado. Si SUNAT actualiza el catálogo (algo frecuente), se requiere redelploy. Debería estar en base de datos o ser una configuración dinámica.

### 5\. Resumen de Cumplimiento

  * **RESTful:** Cumple mayormente. Los verbos HTTP se usan correctamente.
  * **OpenAPI:** Excelente uso de `zod-to-openapi`. La documentación está sincronizada con el código ("Schema-First").
  * **Principios SOLID:**
      * *Single Responsibility:* Los controladores están delgados, la lógica está en modelos/servicios. Bien.
      * *Dependency Inversion:* El `facturador.service.ts` usa una interfaz `IFacturador`. Esto es excelente para cambiar entre Mock y Nubefact.

### Conclusión

El backend tiene una arquitectura sólida y moderna para un MVP o fase inicial. El uso de Prisma, Zod y el patrón Multi-tenant es correcto.

**Acciones Inmediatas Recomendadas:**

1.  **Corregir el test de integración** que referencia la tabla eliminada.
2.  Eliminar archivos `.backup` y scripts JS (`check-tenant.js`) que deberían ser TS o estar fuera de `src`.
3.  Implementar `decimal.js` para cálculos monetarios críticos.
4.  Refactorizar la validación de stock en Ventas para evitar la condición de carrera teórica (aunque mitigada por el bloqueo optimista).
5.  Agregar Rate Limiting.

**Calificación:** 8/10 (Muy bueno, pero con deuda técnica peligrosa en tests y manejo numérico).